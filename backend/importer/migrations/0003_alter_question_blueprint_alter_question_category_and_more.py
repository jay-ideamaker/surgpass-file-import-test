# Generated by Django 5.2.3 on 2025-07-07 04:30
# Manually edited to handle view dependency

from django.db import migrations, models

# The SQL command to drop the view.
# Using "IF EXISTS" makes it safe to run even if the view is already gone.
DROP_VIEW_SQL = "DROP VIEW IF EXISTS questions_with_all_relations;"

# The full SQL definition to recreate the view.
# This is the definition you retrieved from Supabase.
CREATE_VIEW_SQL = """
CREATE VIEW questions_with_all_relations AS
SELECT q.id,
    q.question_bank,
    q.blueprint,
    q.subject,
    q.category,
    q.subcategory,
    q.topic,
    q.difficulty,
    q.question_text,
    q.short_explanation,
    q.full_explanation,
    q.created_at,
    COALESCE(json_agg(DISTINCT jsonb_build_object('name', t.name)) FILTER (WHERE (t.name IS NOT NULL)), '[]'::json) AS tags,
    COALESCE(json_agg(jsonb_build_object('text', ac.text, 'is_correct', ac.is_correct, 'explanation', ac.explanation) ORDER BY ac.is_correct DESC, ac.text) FILTER (WHERE (ac.text IS NOT NULL)), '[]'::json) AS answer_choices,
    COALESCE(json_agg(DISTINCT jsonb_build_object('text', a.text)) FILTER (WHERE (a.text IS NOT NULL)), '[]'::json) AS articles,
    COALESCE(json_agg(jsonb_build_object('question_text', qh.question_text, 'rationale', qh.rationale, 'answers', qh_answers.answers)) FILTER (WHERE (qh.question_text IS NOT NULL)), '[]'::json) AS quick_hits
   FROM ((((((importer_question q
     LEFT JOIN importer_question_tags qt ON ((q.id = qt.question_id)))
     LEFT JOIN importer_tag t ON (((qt.tag_id)::text = (t.name)::text)))
     LEFT JOIN importer_answerchoice ac ON ((q.id = ac.question_id)))
     LEFT JOIN importer_article a ON ((q.id = a.question_id)))
     LEFT JOIN importer_quickhit qh ON ((q.id = qh.parent_question_id)))
     LEFT JOIN ( SELECT qh_inner.id AS quick_hit_id,
            json_agg(jsonb_build_object('text', qha.text, 'is_correct', qha.is_correct) ORDER BY qha.is_correct DESC, qha.text) AS answers
           FROM (importer_quickhit qh_inner
             LEFT JOIN importer_quickhitanswerchoice qha ON ((qh_inner.id = qha.quick_hit_id)))
          GROUP BY qh_inner.id) qh_answers ON ((qh.id = qh_answers.quick_hit_id)))
  GROUP BY q.id, q.question_bank, q.blueprint, q.subject, q.category, q.subcategory, q.topic, q.difficulty, q.question_text, q.short_explanation, q.full_explanation, q.created_at
  ORDER BY q.created_at DESC;
"""


class Migration(migrations.Migration):

    dependencies = [
        ('importer', '0002_add_question_bank'),
    ]

    operations = [
        # Step 1: Drop the dependent view before altering the table.
        migrations.RunSQL(
            sql=DROP_VIEW_SQL,
            reverse_sql=CREATE_VIEW_SQL
        ),

        # Original Django-generated operations to alter the fields.
        migrations.AlterField(
            model_name='question',
            name='blueprint',
            field=models.TextField(blank=True, null=True),
        ),
        migrations.AlterField(
            model_name='question',
            name='category',
            field=models.TextField(blank=True, null=True),
        ),
        migrations.AlterField(
            model_name='question',
            name='question_bank',
            field=models.TextField(blank=True, null=True),
        ),
        migrations.AlterField(
            model_name='question',
            name='subcategory',
            field=models.TextField(blank=True, null=True),
        ),
        migrations.AlterField(
            model_name='question',
            name='subject',
            field=models.TextField(blank=True, null=True),
        ),
        migrations.AlterField(
            model_name='question',
            name='topic',
            field=models.TextField(blank=True, null=True),
        ),

        # Step 2: Recreate the view after the table has been successfully altered.
        migrations.RunSQL(
            sql=CREATE_VIEW_SQL,
            reverse_sql=DROP_VIEW_SQL
        ),
    ]